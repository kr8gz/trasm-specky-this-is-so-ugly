#[cache_output]

extract import "constant.spwn"

impl @trasm {
    run: (self) {
        get_variable = (name: @string) {
            // dont forget local variables :bingu:
        }

        set_variable = (name: @string, val) {

        }

        not_inferable_type_conversion = (typ, let val) {
            if val is @string && val != "?" {
                val = get_variable(val)
            }

            if val is @number {
                return typ(val)
            }

            if val == "?" {
                return match typ {
                    == @group: ?g,
                    == @color: ?c,
                    == @item: ?i,
                }
            }

            return self.log("ERROR: can only convert number to " + match typ {
                == @group: "group",
                == counter: "counter", // counter(x) creates a new counter while the others convert to the type idk specky you write
                == @color: "color",
                == @item: "item ID",
            }, val.line)
        }

        eval_value = (value: @dictionary) {
            return match value.typ {
                == "num" | == "str": value.val,
                == "group": not_inferable_type_conversion(@group, value.val),
                == "ctr": not_inferable_type_conversion(counter, value.val),
                == "col": not_inferable_type_conversion(@color, value.val),
                == "item": not_inferable_type_conversion(@item, value.val),
                == "word": get_variable(value.val),
                == "array": [eval_value(val) for val in value.val]
            }
        }

        let run_function

        run_statement = (name: @string, args: [@dictionary]) {
            match name {
                =="set": _,
                =="add": _,
                =="sub": _,
                =="mul": _,
                =="div": _,
                =="mod": _,
                =="pow": _,
                =="spwn": _,
                =="call": _,
                =="cmp": _,
            }
        }

        get_function = (context: @string | @number) -> @dictionary | @NULL {
            for function in self.parsed.functions {
                if function.context == context {
                    return function
                }
            }
            return null
        }

        run_function = (context: @string | @number, args: [@dictionary] = []) {


            // if self.parsed.functions[name].args.length != args.length {
                //self.log(eXPECTED other amount of arguments:rage:)
            //}
        }

        // initialize constants and variables
        for section in self.parsed.definitions {
            for entry in section.entries {
                match section.typ {
                    in const_define_section_tokens: self.constants.set(entry.name, eval_value(entry.val)),
                    in var_define_section_tokens:   self.variables.set(entry.name, eval_value(entry.val)),
                }
            }
        }

        // TODO: idk use match or shit  // start_contexts array (specky job) ok zoomer
        if is_function("start") { run_function("start") }//////////////////SPEcjy
        else if is_function(0)  { run_function("0") } // sex
        else {
            self.log("ERROR: no start function found")
        }
    }
}
