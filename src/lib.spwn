#[cache_output]

letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

not_inferable_types = ["group", "ctr", "col", "item"]
const_define_section_tokens = ["c", "const", "consts", "constant", "constants"]
var_define_section_tokens = ["v", "var", "vars", "variable", "variables"]

type @token

impl @token {
    matches: (self, typ: @string | @array, val = @NULL) -> @bool {
        return (
            (
                (typ is @array && self.typ in typ)
                || self.typ == typ
            )
            && (
                (val is @array && self.val in val)
                || self.val == val
                || val == @NULL
            )
        )
    },
}

#[desc("TrIGgER ASSembly")]
type @trasm

impl @trasm {
    from_str: (code: @string) {
        let trasm = @trasm::{
            lines: code.split("\n"),
            error: false,
            variables: {},
            constants: {},
        }
        let trasm.lexed = trasm.lex()
        $.print(trasm.lexed)
        let trasm.parsed = trasm.parse()
        $.print(trasm.parsed)
    },

    from_file: (name: @string) {
        return @trasm::from_str($.readfile(name))
    },

    lex: (self) {
        let tokens = []
        let curr_line_index = 1
        let curr_line = null
        let start_index = 1
        let curr_char_index = 1
        let curr_char = null

        push_token = (typ: @string, val) {
            return tokens.push(@token::{
                typ: typ,
                val: val,
                line: curr_line_index,
                col_start: start_index,
                col_end: curr_char_index,
            })
        }

        update_char = () {
            curr_char = curr_line[curr_char_index] if curr_char_index < curr_line.length else null
        }

        next = () {
            curr_char_index++
            update_char()
        }
        prev = () {
            curr_char_index--
            update_char()
        }

        lex_word = () {
            let word = curr_char
            while true {
                next()
                if curr_char != null && (curr_char in letters || (!word.is_empty() && curr_char.is_digit())) {
                    word += curr_char
                } else {
                    prev()
                    return push_token("word", word)
                }
            }
        }

        lex_num = () {
            let num = curr_char
            let float = false

            while true {
                next()

                if curr_char == "." {
                    if float {
                        return self.log(curr_line_index, "ERROR: more than one decimal point in number")
                    } else {
                        float = true
                        num += curr_char
                    }
                } else if curr_char == null || !curr_char.is_digit() {
                    prev()
                    return push_token("num", num as @number)
                } else {
                    num += curr_char
                }
            }
        }

        lex_str = (quotes: @string) {
            let str = ""
            let escape = false

            while true {
                next()

                if escape {
                    str += match curr_char {
                        == "n" : "\n",
                        == "t" : "\t",
                        == "\\": "\\",
                        == "'" : "'",
                        == '"' : '"',
                        else: (){
                            self.log(curr_line_index, "ERROR: invalid escape sequence")
                            return ""
                        }(),
                    }
                    escape = false
                } else if curr_char == "\\" {
                    escape = true
                } else if curr_char == quotes {
                    return push_token("str", str)
                } else if curr_char == null {
                    return self.log(curr_line_index, "ERROR: unclosed string")
                } else {
                    str += curr_char
                }
            }
        }

        for i in 0..self.lines.length {
            curr_line_index = i
            curr_line = self.lines[i]
            curr_char_index = -1
            
            while true {
                next()
                start_index = curr_char_index

                if curr_char == null || curr_char == ";" { break }
                else if curr_char in letters { lex_word() }
                else if curr_char.is_digit() { lex_num() }
                else if curr_char in "\"'" { lex_str(curr_char) }
                else if !(curr_char in " \t") { push_token("sym", curr_char) }

                if self.error { return }
            }
        }

        return tokens
    },

    parse: (self) {
        // organize the tokens into an array of lines
        let lines = []
        let lineno = -1

        for token in self.lexed {
            if token.line > lineno { lines.push([]) }
            lineno = token.line
            lines[-1].push(token)
        }

        // parser checks
        get_define_section = (line: @array) -> @string | @NULL {
            return line[1].val if
            
                line.length == 2 
                && line[0].matches("sym", ".")
                && line[1].matches("word", const_define_section_tokens + var_define_section_tokens)
                
            else null
        }

        get_function_section = (line: @array) -> @string | @NULL {
            return line[0].val if

                line.length == 2
                && line[0].matches(["word", "number"])
                && line[1].matches("sym", ":")

            else null
        }

        get_label = (line: @array) -> @string | @NULL {
            line[0].val if

                line.length == 2
                && line[0].matches("word")
                && line[1].matches("sym", ">")

            else null
        }

        // specific parsing functions
        parse_value = (value: @array) {
            if value.length < 1 {
                return null
            }

            if value[0].matches("word", not_inferable_types) && value[1].matches("number") {
                match value[0].val {
                    == "group": @group(value[1].val),
                    // idk or with a dictionarh with type and value
                    // and also check iof length is 2 or something
                    // and error
                    // and mm
                    // and how array
                    // mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm

                }
            }
            // sdfdjfsdjfsdkjfsdkjfkjsdf
            // help me


        }

        parse_arguments = (arguments: @array) -> @array | @NULL {
            return []
        }

        parse_definition = (line: @array, kind: @string) -> @dictionary | @NULL {
            thing = match kind {
                in const_define_section_tokens: "constant",
                in var_define_section_tokens: "variable",
            }

            if line.length < 2 {
                return self.log(line[0], "ERROR: invalid {} definition".fmt(thing))
            }

            if !line[0].matches("word") {
                return self.log(line[0], "ERROR: expected {} name".fmt(thing))
            }

            return {
                typ: thing,
                name: line[0].val,
                value: parse_value(line[1:]),
            }
        }

        parse_operation = (line: @array) -> @dictionary | @NULL {
            if line.length < 2 {
                return self.log(line[0], "ERROR: invalid statement")
            }

            if !line[0].matches("word") {
                return self.log(line[0], "ERROR: expected operation name")
            }

            return {
                typ: "operation",
                name: line[0].val,
                args: parse_arguments(line[1:]),
            }
        }

        // initializing stuff
        let context = {
            typ: null,
            kind: null, // basically sub-type or name of something
        }

        let parsed = {
            definitions: [],
            functions: [],
        }

        for line in lines {
            // check for new context
            define = get_define_section(line)
            if define is @string {
                context.typ = "define"
                context.kind = define
                continue
            }

            function = get_function_section(line)
            if function is @string {
                context.typ = "function"
                context.kind = function
                parsed.functions.push({ label: null, statements: [] })
                continue
            }

            // parse statements
            if context.typ == "define" {
                parsed.definitions.push(parse_definition(line, context.kind))
            }

            else if context.typ == "function" {
                label = get_label(line)
                if label is @string {
                    parsed.functions.push({ label: label, statements: [] })
                    continue
                }

                parsed.functions[-1].statements.push(parse_operation(line))
            }

            else {
                self.log(line[0], "ERROR: expected a define or function section")
            }

            if self.error { return }
        }

        return parsed
    },

    run: (self) {

    },

    log: (self, context: @token | @number, msg: @string) {
        [ line_index, col_start, col_end ] = match context {
            @number: [ context, null, null ],
            @token: [ context.line, context.col_start, context.col_end + 1 ],
        }

        line_context = "{} | ".fmt(line_index + 1)

        if msg.starts_with("ERROR") {
            self.error = true
            $.print("\u{1B}[0;31m", line_context, self.lines[line_index])
        } else {
            $.print(line_context, self.lines[line_index])
        }

        if col_start != null && col_end != null {
            $.print(" " * (line_context.length + col_start), "^" * (col_end - col_start))
        }

        $.print(msg, "\u{1B}[0;0m\n") // clear color
    },
}
