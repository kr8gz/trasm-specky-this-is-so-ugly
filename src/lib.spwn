#[cache_output]

lexed_line_pattern = [@string]|@NULL
lexed_code_pattern = [lexed_line_pattern]

#[desc("TRigger ASseMbly compiler")]
type @trasm

impl @trasm {
    new: #[constructor, desc("Generates a TRASM output from code")] (code: @string, run: @bool = true) {
        let trasm = @trasm::{
            code: code,
            lexed: @trasm::lex(code),
        }
        return trasm
    },
    lex: #[desc("Lexes the code")] (code: @string) -> lexed_code_pattern {
        lines = code.split("\n")
        let output = []
        for i in 0..lines.length {
            output.push(@trasm::lex_line(lines[i], i))
        }
        return output
    },
    lex_line: #[desc("Lexes a line of code")] (line: @string, index: @number) -> lexed_line_pattern {
        // "what isn't current is previous" - specky 2022
        let previous = []
        let current = ""
        // "what isnt current or future is previous" - bombie 2022
        future = (force: @bool = false){
            if current != "" || force {
                previous.push(current)
                current = ""
            }
        }

        let is_string = false

        for char in line {
            let skip = false

            if is_string != false {
                if char == is_string {
                    is_string = false
                    future(true)
                } else {
                    current += char
                }
                continue
            }

            match char {
                ==' ': future(),
                ==',': (){
                    future()
                    previous.push(char)
                }(),
                ==':': (){
                    if previous.length == 0 {
                        future()
                        previous.push(char)
                    } else { current += char }
                }(),
                =='.': (){
                    if previous.length == 0 && current == "" {
                        current += char;
                        future()
                    } else { current += char }
                }(),
                in '"\'': (is_string = char),
                ==';': (skip = true),
                else: (current += char),
            }
            if skip { break }
        }

        future()

        if is_string != false {
            return @trasm::error_line(line, index, "Unterminated string")
        }

        return previous
    },
    parse: #[desc("Parses the lexed code")] (self) -> @NULL {
        if !$.mutability(self) {
            throw "Cannot save parsed lexed code on immutable instance"
        }
        if "parsed" in self {
            return self
        }

        let self.parsed = {
            functions: {},
            values: {}, // constants and variables
        }

        let context = null

        for i in 0..self.lexed.length {
            let line = self.lexed[i]
            if line is @NULL { return @trasm::error_line(line, i, "Invalid line") }
            if line.length == 0 { continue }

            // insert here parsing logic
        }
    },
    error_line: #[desc("Prints an error line")] (line: @string, index: @number, error: @string) -> @NULL {
        $.print("{} | {}\nERROR: {}".fmt([index + 1, line, error]))
    },
}
