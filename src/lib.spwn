#[cache_output]

lexed_success_pattern = [@string]
lexed_line_pattern = lexed_success_pattern|@NULL
lexed_code_pattern = [lexed_line_pattern]
typedefs = ["var", "str", "num", "ctr", "id", "gr", "col"]

#[desc("TRigger ASseMbly compiler")]
type @trasm

impl @trasm {
    new: #[constructor, desc("Generates a TRASM output from code")] (code: @string, run: @bool = true) {
        let trasm = @trasm::{
            code: code,
            lexed: @trasm::lex(code),
        }
        trasm.parse()
        return trasm
    },
    lex: #[desc("Lexes the code")] (code: @string) -> lexed_code_pattern {
        lines = code.split("\n")
        let output = []
        for i in 0..lines.length {
            output.push(@trasm::lex_line(lines[i], i))
        }
        return output
    },
    lex_line: #[desc("Lexes a line of code")] (line: @string, index: @number) -> lexed_line_pattern {
        // "what isn't current is previous" - specky 2022
        let previous = []
        let current = ""
        // "what isnt current or future is previous" - bombie 2022
        future = (force: @bool = false){
            if current != "" || force {
                previous.push(current)
                current = ""
            }
        }

        let is_string = false

        for char in line {
            let skip = false

            if is_string != false {
                if char == is_string {
                    is_string = false
                    future(true)
                } else {
                    current += char
                }
                continue
            }

            match char {
                ==' ': future(),
                ==',': (){
                    future()
                    previous.push(char)
                }(),
                ==':': (){
                    if previous.length == 0 {
                        future()
                        previous.push(char)
                    } else { current += char }
                }(),
                =='.': (){
                    if previous.length == 0 && current == "" {
                        current += char;
                        future()
                    } else { current += char }
                }(),
                in '"\'': (is_string = char),
                ==';': (skip = true),
                else: (current += char),
            }
            if skip { break }
        }

        future()

        if is_string != false {
            return @trasm::log(line, index, "ERROR", "Unterminated string")
        }

        return previous
    },
    parse: #[desc("Parses the lexed code")] (self) -> @trasm { // apparently it implicitly returns trasm
        if !$.mutability(self) {
            throw "Cannot save parsed lexed code on immutable instance"
        }
        if "parsed" in self {
            return self
        }

        let self.parsed = {
            functions: {},
            values: {}, // constants and variables
        }

        let context = null

        for i in 0..self.lexed.length {
            let line = self.lexed[i]
            if line.length == 0 { continue }

            if line[0] == '.' {
                match line.length {
                    <2: @trasm::log(line, i, "ERROR", "Expected section name, got nothing"),
                    >2: @trasm::log(line, i, "ERROR", "Too many arguments"),
                    ==2: (){
                        match line[1].lowercase() {
                            =="c"|=="consts"|=="constants": (context = 1),
                            =="v"|=="vars"|=="variables": (context = 2),
                            else: @trasm::log(line, i, "ERROR", "Unknown section name"),
                        }
                    }(),
                }
            }

            if line.length >= 2 && line[1] == ':' {
                let name = line[0]
                let args = []
                if line.length > 2 {
                    args += @trasm::parse_list(line[2:], self.code.split("\n")[i], i) if is @array else [null]
                }

            }
        }
    },
    parse_list: #[desc("Parses a comma separated list")] (input: [@string], line: @string, index: @number) {
        if input[0] == ',' {
            return @trasm::log(line, index, "ERROR", "Expected space to separate operator from arguments, got comma")
        }    

        let i = 0
        let arguments = []

        while true {
            if input[i] in typedefs {
                if i + 1 >= input.length || input[i + 1] == ',' {
                    return @trasm::log(line, index, "ERROR", "Expected value after type definition")
                }
                arguments.push({
                    typ: input[i],
                    val: input[i + 1],
                })
                i++
            } else if input[i] != ',' {
                arguments.push({
                    typ: "var",
                    val: input[i],
                })
                if i + 1 >= input.length || input[i + 1] == ',' {
                    i++
                } else {
                    return @trasm::log(line, index, "ERROR", "Expected comma to separate arguments")
                }
            } else {
                return @trasm::log(line, index, "ERROR", "Unexpected comma")
            }
            
            i++
            if i >= input.length { break }
        }
        return arguments
    },
    log: #[desc("logs something to console")] (line: @string, index: @number, typ: @string, message: @string) -> @NULL {
        $.print("{} | {}\n{}: {}".fmt([index + 1, line, typ, message]))
    },
}
