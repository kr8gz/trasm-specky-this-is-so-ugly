#[cache_output]

extract import "constant.spwn"

impl @trasm {
    parse: (self) {
        // organize the tokens into an array of lines
        let lines = []
        let lineno = -1

        for token in self.lexed {
            if token.line > lineno { lines.push([]) }
            lineno = token.line
            lines[-1].push(token)
        }

        // these check for new modes
        get_define_section = (line: @array) -> @string | @NULL {
            return line[1].val if
            
                line.length == 2 
                && line[0].matches("sym", ".")
                && line[1].matches("word", const_define_section_tokens + var_define_section_tokens)
                
            else null
        }

        get_function_section = (line: @array) -> @string | @number | @NULL {
            return line[0].val if

                line.length >= 2
                && line[0].matches(["word", "num"])
                && line[1].matches("sym", ":")

            else null
            // parse_arguments
        }

        get_label = (line: @array) -> @string | @NULL {
            return line[0].val if

                line.length == 2
                && line[0].matches("word")
                && line[1].matches("sym", ">")

            else null
        }

        // specific parsing functions
        parse_value = (value: @array) {
            if value.length < 1 {
                return null
            }

            if value[0].matches("word", not_inferable_types) && value[1].matches("number") {
                match value[0].val {
                    == "group": @group(value[1].val),
                    // idk or with a dictionarh with type and value
                    // and also check iof length is 2 or something
                    // and error
                    // and mm
                    // and how array
                    // mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm

                }
            }
            // sdfdjfsdjfsdkjfsdkjfkjsdf
            // help me


        }

        parse_arguments = (arguments: @array) -> @array | @NULL {
            return []
        }

        parse_definition = (line: @array, typ: @string) -> @dictionary | @NULL {
            thing = match typ {
                in const_define_section_tokens: "constant",
                in var_define_section_tokens: "variable",
            }

            if line.length < 2 {
                return self.log(line[0], "ERROR: invalid {} definition".fmt(thing))
            }

            if !line[0].matches("word") {
                return self.log(line[0], "ERROR: expected {} name".fmt(thing))
            }

            return {
                typ: thing,
                name: line[0].val,
                value: parse_value(line[1:]),
            }
        }

        parse_operation = (line: @array) -> @dictionary | @NULL {
            if line.length < 2 || line[1].matches("sym") {
                return self.log(line[0], "ERROR: invalid statement")
            }

            if !line[0].matches("word") {
                return self.log(line[0], "ERROR: expected operation name")
            }

            return {
                typ: "operation",
                name: line[0].val,
                args: parse_arguments(line[1:]),
            }
        }

        // initializing stuff
        let mode = {
            typ: null,
            data: null, // basically sub-type or name of something
        }

        let parsed = {
            definitions: [],
            functions: [],
        }

        for line in lines {
            // check for new modes
            define = get_define_section(line)
            if define != null {
                mode.typ = "define"
                mode.data = define
                continue
            }

            function = get_function_section(line)
            if function != null {
                mode.typ = "function"
                parsed.functions.push({
                    context: function,
                    sections: [
                        {
                            label: null,
                            statements: []
                        }
                    ]
                })
                continue
            }

            // parse statements
            if mode.typ == "define" {
                parsed.definitions.push(parse_definition(line, mode.data))
            }

            else if mode.typ == "function" {
                label = get_label(line)
                if label != null {
                    parsed.functions[-1].sections.push({ label: label, statements: [] })
                    continue
                }

                parsed.functions[-1].sections[-1].statements.push(parse_operation(line))
            }

            else {
                self.log(line[0], "ERROR: expected a define or function section")
            }

            if self.error { return }
        }

        return parsed
    },
}
